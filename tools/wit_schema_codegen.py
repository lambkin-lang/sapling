#!/usr/bin/env python3
"""
Generate DBI manifest and C metadata from WIT schema record declarations.

Convention:
  record dbi<index>-<name>-key { ... }
  record dbi<index>-<name>-value { ... }
"""

from __future__ import annotations

import argparse
import csv
import re
import sys
from dataclasses import dataclass
from pathlib import Path


RECORD_RE = re.compile(r"(?m)^\s*record\s+([a-z0-9][a-z0-9-]*)\s*\{")
DBI_REC_RE = re.compile(r"^dbi([0-9]+)-([a-z0-9][a-z0-9-]*)-(key|value)$")


@dataclass
class DbiEntry:
    dbi: int
    name: str
    key_record: str
    value_record: str

    @property
    def c_name(self) -> str:
        return self.name.replace("-", "_").upper()


def parse_dbi_entries(wit_text: str) -> list[DbiEntry]:
    per_dbi: dict[int, dict[str, str]] = {}
    names_by_dbi: dict[int, str] = {}

    for rec_name in RECORD_RE.findall(wit_text):
        m = DBI_REC_RE.match(rec_name)
        if not m:
            continue
        dbi = int(m.group(1), 10)
        name = m.group(2)
        kind = m.group(3)

        if dbi in names_by_dbi and names_by_dbi[dbi] != name:
            raise ValueError(
                f"dbi {dbi} has multiple names ({names_by_dbi[dbi]!r} vs {name!r})"
            )
        names_by_dbi[dbi] = name

        slot = per_dbi.setdefault(dbi, {})
        if kind in slot:
            raise ValueError(f"duplicate {kind} record for dbi {dbi}: {rec_name}")
        slot[kind] = rec_name

    if not per_dbi:
        raise ValueError("no dbi records found (expected dbiN-*-key/value records)")

    dbis = sorted(per_dbi.keys())
    if dbis[0] != 0:
        raise ValueError("dbi sequence must start at 0")
    for prev, cur in zip(dbis, dbis[1:]):
        if cur != prev + 1:
            raise ValueError(f"dbi sequence gap between {prev} and {cur}")

    entries: list[DbiEntry] = []
    for dbi in dbis:
        slot = per_dbi[dbi]
        if "key" not in slot or "value" not in slot:
            raise ValueError(f"dbi {dbi} missing key/value pair: {slot}")
        entries.append(
            DbiEntry(
                dbi=dbi,
                name=names_by_dbi[dbi],
                key_record=slot["key"],
                value_record=slot["value"],
            )
        )
    return entries


def write_manifest(entries: list[DbiEntry], out_path: Path) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with out_path.open("w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f, lineterminator="\n")
        writer.writerow(["dbi", "name", "key_format", "value_format", "owner", "status"])
        for e in entries:
            status = "active" if e.dbi == 0 else "planned"
            writer.writerow(
                [
                    str(e.dbi),
                    e.name.replace("-", "_"),
                    f"wit:{e.key_record}",
                    f"wit:{e.value_record}",
                    "runtime",
                    status,
                ]
            )


def write_c_header(entries: list[DbiEntry], out_path: Path) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)
    guard = "SAPLING_WIT_SCHEMA_DBIS_H"
    lines = [
        "/* Auto-generated by tools/wit_schema_codegen.py; DO NOT EDIT. */",
        f"#ifndef {guard}",
        f"#define {guard}",
        "",
        "#include <stdint.h>",
        "",
        "typedef struct {",
        "    uint32_t dbi;",
        "    const char *name;",
        "    const char *key_wit_record;",
        "    const char *value_wit_record;",
        "} SapWitDbiSchema;",
        "",
    ]
    for e in entries:
        lines.append(f"#define SAP_WIT_DBI_{e.c_name} {e.dbi}u")
    lines.extend(
        [
            "",
            "extern const SapWitDbiSchema sap_wit_dbi_schema[];",
            "extern const uint32_t sap_wit_dbi_schema_count;",
            "",
            f"#endif /* {guard} */",
            "",
        ]
    )
    out_path.write_text("\n".join(lines), encoding="utf-8")


def write_c_source(entries: list[DbiEntry], header_path: Path, out_path: Path) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)
    rel_header = header_path.as_posix()
    lines = [
        "/* Auto-generated by tools/wit_schema_codegen.py; DO NOT EDIT. */",
        f'#include "{rel_header}"',
        "",
        "const SapWitDbiSchema sap_wit_dbi_schema[] = {",
    ]
    for e in entries:
        lines.append(
            f'    {{{e.dbi}u, "{e.name.replace("-", "_")}", "{e.key_record}", "{e.value_record}"}},'
        )
    lines.extend(
        [
            "};",
            "",
            "const uint32_t sap_wit_dbi_schema_count = "
            "(uint32_t)(sizeof(sap_wit_dbi_schema) / sizeof(sap_wit_dbi_schema[0]));",
            "",
        ]
    )
    out_path.write_text("\n".join(lines), encoding="utf-8")


def main(argv: list[str]) -> int:
    p = argparse.ArgumentParser()
    p.add_argument("--wit", required=True, help="Input WIT file containing dbi records")
    p.add_argument("--manifest", required=True, help="Output CSV manifest path")
    p.add_argument("--header", required=True, help="Output generated C header path")
    p.add_argument("--source", required=True, help="Output generated C source path")
    args = p.parse_args(argv)

    wit_path = Path(args.wit)
    if not wit_path.exists():
        print(f"wit-schema: FAIL: file not found: {wit_path}", file=sys.stderr)
        return 1

    try:
        entries = parse_dbi_entries(wit_path.read_text(encoding="utf-8"))
        write_manifest(entries, Path(args.manifest))
        write_c_header(entries, Path(args.header))
        write_c_source(entries, Path(args.header), Path(args.source))
    except Exception as exc:  # noqa: BLE001
        print(f"wit-schema: FAIL: {exc}", file=sys.stderr)
        return 1

    print(
        "wit-schema: PASS "
        f"(entries={len(entries)} wit={wit_path} manifest={args.manifest} header={args.header})"
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
